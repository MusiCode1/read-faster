# אסטרטגיות לארגון מילים: ערבוב מול חלוקה לפי שלב

## רקע

במערכת הנוכחית, המילים מאורגנות במבנה נתונים אחד ומסוננות לפי שלב בזמן ריצה. המשתמש בוחר שלב, והמערכת מסננת את המילים המתאימות לשלב זה. השאלה היא האם כדאי לשנות את הגישה ולחלק את המילים לפי שלב מראש.

## גישה 1: מאגר מילים אחד עם סינון דינמי (המצב הנוכחי)

### יתרונות:

1. **פשטות מבנה הנתונים** - מבנה נתונים אחד פשוט המכיל את כל המילים.
2. **מניעת כפילות** - כל מילה מוגדרת פעם אחת בלבד, גם אם היא מופיעה במספר שלבים.
3. **קלות עדכון** - עדכון מילה (טקסט, תמונה וכו') מתבצע במקום אחד בלבד.
4. **גמישות בהגדרת שלבים** - קל להגדיר שלבים חדשים או לשנות את הקריטריונים לשיוך מילים לשלבים.

### חסרונות:

1. **ביצועים** - סינון המילים בזמן ריצה דורש משאבי מעבד (אם כי זניחים במקרה שלנו).
2. **מורכבות לוגית** - הלוגיקה של סינון המילים מתפזרת בקוד במקומות שונים.
3. **קושי בהתאמה אישית של שלבים** - קשה יותר להגדיר סדר ספציפי של מילים בכל שלב.

## גישה 2: חלוקה מראש לפי שלב

### יתרונות:

1. **ביצועים משופרים** - אין צורך בסינון בזמן ריצה, המילים כבר מחולקות לפי שלב.
2. **פשטות לוגית** - הלוגיקה פשוטה יותר, אין צורך בפונקציות סינון.
3. **שליטה מדויקת** - אפשר לקבוע בדיוק אילו מילים יופיעו בכל שלב ובאיזה סדר.
4. **הפרדת דאגות** - כל שלב מוגדר בנפרד, מה שמקל על תחזוקה ממוקדת.
5. **גמישות בתוכן** - אפשר להגדיר מילים שונות לגמרי בכל שלב, ללא תלות בשלבים אחרים.

### חסרונות:

1. **כפילות אפשרית** - אם מילה מופיעה ביותר משלב אחד, היא תישמר פעמיים (או יותר).
2. **קושי בעדכון גלובלי** - עדכון מילה שמופיעה במספר שלבים דורש עדכון בכל המקומות.
3. **מורכבות מבנה הנתונים** - מבנה נתונים מורכב יותר (מפה של מערכים לפי שלב).

## פתרונות אפשריים

### 1. חלוקה מראש עם מניעת כפילות

ניתן לשלב את היתרונות של שתי הגישות על ידי שמירת מאגר מילים מרכזי והפניות אליו מהשלבים השונים:

```typescript
// מאגר מילים מרכזי
const wordDictionary: Record<string, Word> = {
	בית: { id: 'home', text: 'בית', level: 1 },
	כלב: { id: 'dog', text: 'כלב', level: 1 },
	חתול: { id: 'cat', text: 'חתול', level: 2 }
	// ...
};

// הפניות לפי שלב
const wordsByLevel: Record<number, string[]> = {
	1: ['בית', 'כלב'],
	2: ['בית', 'חתול']
	// ...
};

// פונקציה לקבלת המילים לפי שלב
function getWordsForLevel(level: number): Word[] {
	return wordsByLevel[level]?.map((wordKey) => wordDictionary[wordKey]) || [];
}
```

יתרונות הגישה הזו:

- אין כפילות של הגדרות מילים
- עדכון מילה מתבצע במקום אחד
- ביצועים טובים כי אין צורך בסינון
- שליטה מדויקת בסדר ותוכן המילים בכל שלב

### 2. מבנה היברידי

גישה אחרת היא לשמור את המילים במבנה היברידי:

```typescript
interface Word {
	id: string;
	text: string;
	image?: string;
	// שדות נוספים...
}

interface LevelWord {
	wordId: string; // הפניה למילה במילון
	order: number; // סדר הופעה בשלב
	// הגדרות ספציפיות לשלב...
	repetitions?: number; // מספר חזרות ספציפי לשלב
}

// מילון מילים
const words: Record<string, Word> = {
	/* ... */
};

// מילים לפי שלב
const levelWords: Record<number, LevelWord[]> = {
	/* ... */
};
```

יתרונות:

- הפרדה בין הגדרת המילה הבסיסית לבין ההגדרות הספציפיות לשלב
- אפשרות להגדיר פרמטרים ייחודיים לכל מילה בכל שלב
- שמירה על יעילות וגמישות

## המלצה

בהתחשב בדרישות המערכת ובעקרונות התכנות הפונקציונלי, אני ממליץ על **גישה 1 - חלוקה מראש עם מניעת כפילות**:

1. שמירת מילון מילים מרכזי עם כל המידע על כל מילה
2. שמירת מערכים של מזהי מילים לפי שלב
3. פונקציות טהורות לשליפת המילים לפי שלב

יתרונות הגישה הזו:

- שומרת על עקרונות התכנות הפונקציונלי
- מונעת כפילות נתונים
- מאפשרת שליטה מדויקת בתוכן כל שלב
- מפשטת את הלוגיקה של המערכת

## דוגמת יישום

```typescript
// src/lib/data/words.ts

// הגדרת המילון המרכזי
export const wordDictionary: Record<string, Word> = {
	בית: {
		id: 'home',
		text: 'בית',
		image: '/images/home.jpg'
	},
	כלב: {
		id: 'dog',
		text: 'כלב',
		image: '/images/dog.jpg'
	}
	// ...
};

// הגדרת המילים לפי שלב
export const wordsByLevel: Record<number, string[]> = {
	1: ['בית', 'כלב', 'חתול', 'פרה'],
	2: ['בית', 'ספר', 'עט', 'מחברת'],
	3: ['מחשב', 'טלפון', 'טלוויזיה', 'רדיו']
	// ...
};

// פונקציה טהורה לקבלת המילים לפי שלב
export function getWordsForLevel(level: number): Word[] {
	const wordKeys = wordsByLevel[level] || [];
	return wordKeys.map((key) => wordDictionary[key]).filter(Boolean);
}

// פונקציה טהורה לקבלת מילה לפי מזהה
export function getWordById(id: string): Word | undefined {
	return wordDictionary[id];
}
```

בגישה זו, המילים מוגדרות פעם אחת בלבד, אך עדיין יש שליטה מלאה על אילו מילים יופיעו בכל שלב ובאיזה סדר.
